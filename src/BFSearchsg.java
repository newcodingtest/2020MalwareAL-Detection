import java.io.*;
import java.util.*;

public class BFSearchsg {

	static boolean debug = false;
	//static boolean debug = true;
	
	static boolean search_debug = false;
	//static boolean search_debug = true;
	
	static int searchCount = 0;
	
	static int knn_id = -1;
	static int knn_dist = 1000;
	static int dk = 1000;
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
				
		int hashSize = 128;
				
		//int numOfHash = 10;
		//int numOfHash = 100;
		
		//int numOfHash = 10000;
		//int numOfHash = 20000;
		//int numOfHash = 30000;
		//int numOfHash = 40000;
		//int numOfHash = 50000;
		
		//int numOfHash = 6000;
		//int numOfHash = 12000;
		//int numOfHash = 18000;
		int numOfHash = 24000;
		
		//int queryRad = 10;
		//int queryRad = 20;
		int queryRad = 30;
		//int queryRad = 40;
		//int queryRad = 50;
		
		//int fold = 1;
		
		SimHash[] sh = new SimHash[numOfHash];
		SimHash[] query = new SimHash[6000];
		
		try
		{
			
			FileOutputStream fos0 = new FileOutputStream("exp_result_200302.txt");
			DataOutputStream dos0 = new DataOutputStream(fos0);
		
			long avg_bf_search_time = 0;
			for (int fold=1; fold<=1; fold++) {
			//for (int fold=1; fold<=1; fold++) {
				
				System.out.println("fold="+fold);
			
				///////////////////////////////////////////////////////////
				// Read hashes
				///////////////////////////////////////////////////////////
				//readHash(numOfHash, hashSize, sh);
				String fName = "SimHash_24000_"+fold+".txt";
				readHash(numOfHash, hashSize, sh, fName);
				
				SimHash ns = new SimHash();
				for (int i=0; i<hashSize; i++)
				{
					ns.hash[i] = 1;
				}
			
				String malTest = "Malicious_SimHash_3000_"+fold+".txt";
				String normalTest = "Normal_SimHash_3000_"+fold+".txt";
				readTestHash(6000, hashSize, query, malTest, normalTest);
				
				
				//////////////////////////////////////////////////////////////
				// Find kNN by brute-force
				/////////////////////////////////////////////////////////////
				
				long bs, be;
				long total_bf_search_time = 0;
				//bs = System.currentTimeMillis();
				
				int bf_min = 1000;
				int bf_knn = -1;
				int dist = 0;
				int A = 0, B = 0, C = 0;
				
				//System.out.println("===============================");
				for (int j=0; j<numOfHash; j++)
				{
					bs = System.currentTimeMillis();
					bf_min = 1000;
					for (int i=0; i<6000; i++)
					{
						//if (debug) System.out.println(i);
						//if (debug) sh[i].print();
						
						//dist = ns.computeDistance(sh[i]);
						dist = sh[j].computeDistance(query[i]);
						//System.out.println(i+":"+dist);
						
						if (dist < bf_min)
						{
							bf_min = dist;
							bf_knn = i;
							//System.out.printf("j = %d, i = %d, bf_min = %d, bf_knn = %d%n", j, i, bf_min, bf_knn);
						}
						
					}
					// System.out.println("j = " + j + "bf_knn = " + bf_knn);
					
					
					be = System.currentTimeMillis();
					
					if(j<12000 && bf_knn<3000) B++;
					else if(j>=12000 && bf_knn>=3000) A++;
					else C++;
					
					total_bf_search_time += be - bs;
					
					if ((j+1)%3000 == 0)
						System.out.println((j+1)+":Elapsed Search time(ms)="+total_bf_search_time);
				}
				//be = System.currentTimeMillis();
			
				System.out.printf("A(정상) = %d, B(악성) = %d, C(나머지) = %d%n", A, B, C);
				//System.out.println("bf_knn="+bf_knn+":"+"bf_min="+bf_min);
				System.out.println("Time(ms)="+total_bf_search_time);
				avg_bf_search_time += total_bf_search_time;
				
				/*if (knn_id != bf_knn && knn_dist != bf_min)
				{
					System.out.println("knn is different from bf_knn");
					System.out.printf("knn_id=%d, bf_knn=%d\n", knn_id, bf_knn);
					System.out.printf("knn_dist=%d, bf_min=%d\n", knn_dist, bf_min);
					//wrongKNN++;
				}
				else
				{
					System.out.println("knn is same with bf_knn");
					System.out.printf("knn_id=%d, bf_knn=%d\n", knn_id, bf_knn);
					System.out.printf("knn_dist=%d, bf_min=%d\n", knn_dist, bf_min);
				}*/	
				
			} // for fold
			System.out.println("avg search time(ms)="+avg_bf_search_time/5);
		
		}
		catch(Exception e)
		{
			System.out.println(e);
		}
		
		
		
	}

	
	
	
	
	
	static void mTreeSearch(Mnode root, SimHash ns, int queryRad)
	{
		try
		{
			searchCount++;
			
			//FileWriter fw = new FileWriter("CreateLog.txt", true);
			
			// Compute the distance between root and q
			int dist = ns.computeDistance(root.sh[0]);
			//if (search_debug) 
				//System.out.printf("\nDistance between q and node %d=%d, %d\n", 
					//	root.sh[0].id, dist, knn_dist);
			
			if (dist < knn_dist)
			{
				knn_dist = dist;
				knn_id = root.sh[0].id;
				//if (search_debug) System.out.println(knn_id+" is NN:"+knn_dist);
			}
			
			// if min_dist(child, q) > knn_dist, the sub-tree is prunned
			// 1) Left Child
			if (root.leftNode != null)
			{
				/*
				// Compute the distance between the left child and q
				int left_dist = ns.computeDistance(root.leftNode.sh[0]);
				
				int min_dist = Math.max(left_dist - root.leftNode.radius, 0);
				if ( min_dist > knn_dist )
				{
					if (search_debug) 
					{
						System.out.printf("The left child %d is prunned\n", root.leftNode.sh[0].id);
						System.out.printf("min_dist=%d > knn_dist=%d\n", min_dist, knn_dist);
						System.out.printf("left_dist=%d, root.leftNode.radius=%d\n", left_dist, root.leftNode.radius);
					}
				}
				else
					mTreeSearch(root.leftNode, ns, queryRad);
				*/
				
				//int min_dist = Math.max(dist - root.radius, 0);
				int left_dist = ns.computeDistance(root.leftNode.sh[0]);
				int min_dist = Math.max(left_dist - root.leftNode.radius, 0);
				if (min_dist > knn_dist)
				{
					//if (search_debug) 
					//{
						//System.out.printf("\nThe left child %d is prunned\n", root.leftNode.sh[0].id);
						//System.out.printf("left_dist=%d, left_rad=%d\n",left_dist, root.leftNode.radius);
						//System.out.printf("min_dist=%d > knn_dist=%d\n", min_dist, knn_dist);
						
					//}
				}
				else
				{
					//if (search_debug)
					//{
					  //System.out.printf("left_dist=%d, left_rad=%d\n",left_dist, root.leftNode.radius);
					  //System.out.printf("min_dist=%d < knn_dist=%d\n", min_dist, knn_dist);
					//}
					mTreeSearch(root.leftNode, ns, queryRad);
				}
			}
			
			
			// 2) Right Child
			if (root.rightNode != null)
			{
				// Compute the distance between the right child and q
				int right_dist = ns.computeDistance(root.rightNode.sh[0]);
				
				int min_dist = Math.max(right_dist - root.rightNode.radius, 0);
				if ( min_dist > knn_dist )
				{
					//if (search_debug) 
					//{
						//System.out.printf("\nThe right child %d is prunned\n", root.rightNode.sh[0].id);
						//System.out.printf("right_dist=%d, right_rad=%d\n",right_dist, root.rightNode.radius);
						//System.out.printf("min_dist=%d > knn_dist=%d\n", min_dist, knn_dist);
					//}
				}
				else
				{
					//if (search_debug)
					//{
					  //System.out.printf("right_dist=%d, right_rad=%d\n",right_dist, root.rightNode.radius);
					  //System.out.printf("min_dist=%d < knn_dist=%d\n", min_dist, knn_dist);
					//}
					mTreeSearch(root.rightNode, ns, queryRad);
				}
			}
			
			// 3) leaf node
			if (root.leftNode == null && root.rightNode == null)
			{
				//System.out.printf("\nThis is a leaf node=%d\n", root.count);
				for (int i=1; i<root.count; i++)
				{
					// Compute the distance between root and q
					dist = ns.computeDistance(root.sh[i]);
					//if (search_debug) 
					//	System.out.printf("Leaf:Distance between q and node %d=%d, %d\n", 
					//			root.sh[i].id, dist, knn_dist);
					
					if (dist < knn_dist)
					{
						knn_dist = dist;
						knn_id = root.sh[i].id;
						//if (search_debug) System.out.println(knn_id+" is NN:"+knn_dist);
					}
				}
			}
			
			//fw.close();
			
		}
		catch(Exception e)
		{
			
		}
	}
	
	
	static Mnode create(SimHash[] sh2, int numOfHash)
	{		
		Mnode n = new Mnode();
		n.sh = new SimHash[numOfHash];
		n.count = numOfHash;
			
		try
		{
		
		//FileWriter dos = new FileWriter("CreateLog.txt", true);	
			
		for (int i=0; i<numOfHash; i++)
		{
			n.sh[i] = new SimHash();
			n.sh[i] = sh2[i];
			//if (debug) 
				//System.out.print("\t"+n.sh[i].id+"("+n.sh[i].hash[0]+","+n.sh[i].hash[1]+")");
				//dos.write("\t"+n.sh[i].id+"("+n.sh[i].hash[0]+","+n.sh[i].hash[1]+")");
		}
		//if (debug) 
			//System.out.println();
			//dos.write("\nnode="+n.sh[0].id+"th\n");
		
		int[] dist = new int[numOfHash];
		ArrayList al = new ArrayList();
		int total = 0;
		for (int i=0; i<numOfHash; i++)
		{
			dist[i] = n.sh[0].computeDistance(n.sh[i]);
			al.add(dist[i]);
			total += dist[i];
		}
		al.sort(null);
		n.radius = (int)al.get(numOfHash/2);
		
		// When the radius is zero, we set the average to the raduis instead of the median
		if (n.radius == 0)
		{
			n.radius = total / numOfHash;
		}
		
		//if (debug) 
		//{
			//System.out.println("rad="+n.radius);
			//dos.write("rad="+n.radius+"\n");
			
			//for (int i=0; i<numOfHash; i++)
				//dos.write(al.get(i)+", ");
			//dos.write("\n");		
		//}
		
		SimHash[] left = new SimHash[numOfHash];
		SimHash[] right = new SimHash[numOfHash];
		int leftCount = 0;
		int rightCount = 0;
		
		for (int i=1; i<numOfHash; i++)
		{
			if (dist[i] <= n.radius)
			{
				left[leftCount] = new SimHash();
				left[leftCount] = n.sh[i];
				left[leftCount].id = n.sh[i].id;
				leftCount++;
			}
			else
			{
				right[rightCount] = new SimHash();
				right[rightCount] = n.sh[i];
				right[rightCount].id = n.sh[i].id;
				rightCount++;
			}
		}
		if (debug) 
		{	//System.out.println(leftCount+":"+rightCount);
			//dos.write("LeftCount="+leftCount+":RightCount="+rightCount+"\n");
			
			//if (leftCount > 0) dos.write("LeftChild="+left[0].id+"\n");
			//if (rightCount > 0) dos.write(":RightChild="+right[0].id+"\n");
		}
		
		///////////////////////////////////////////////////////
		// Left Child
		///////////////////////////////////////////////////////
		if (leftCount >= 3)
		{
			//if (debug) 
				//System.out.println("Creating left child");
				//dos.write("\nCreating left child\n");
			
			//dos.close();
			n.leftNode = create(left, leftCount);
		}
		else
		{
			//if (debug) 
				//System.out.println("No Left Child:"+leftCount);
				//dos.write("No Left Child:"+leftCount+"\n");
			
			Mnode lc = new Mnode();
			lc.sh = new SimHash[leftCount];
			
			for (int i=0; i<leftCount; i++)
			{
				lc.sh[i] = new SimHash();
				lc.sh[i] = left[i];
				//System.out.print("\t"+n.sh[i].id+"("+n.sh[i].hash[0]+","+n.sh[i].hash[1]+")");
				//dos.write(i+":"+lc.sh[i].id+"\n");
			}
			n.leftNode = lc;
			lc.count = leftCount;
			
			// Leaf node's radius
			if (leftCount == 2)
			{
				lc.radius = lc.sh[0].computeDistance(lc.sh[1]); 
				//dos.write("Leaf node radius="+lc.radius+"\n");
			}
		
			//dos.close();
		}
		//dos.close();
		
		
		//dos = new FileWriter("CreateLog.txt", true);
		
		// Right Child
		if (rightCount >= 3)
		{
			//if (debug) 
				//System.out.println("Creating right child");
				//dos.write("\nCreating right child\n");
			
			//dos.close();
			n.rightNode = create(right, rightCount);
		}
		else
		{
			//if (debug) 
				//System.out.println("No Right Child:"+rightCount);
				//dos.write("No Right Child:"+rightCount+"\n");
			Mnode rc = new Mnode();
			rc.sh = new SimHash[rightCount];
			
			for (int i=0; i<rightCount; i++)
			{
				rc.sh[i] = new SimHash();
				rc.sh[i] = right[i];
				//System.out.print("\t"+n.sh[i].id+"("+n.sh[i].hash[0]+","+n.sh[i].hash[1]+")");
				//dos.write(i+":"+rc.sh[i].id+"\n");
			}
			n.rightNode = rc;
			rc.count = rightCount;
			
			// Leaf node's radius
			if (rightCount == 2)
			{
				rc.radius = rc.sh[0].computeDistance(rc.sh[1]); 
				//dos.write("Leaf node radius="+rc.radius+"\n");
			}
		}
		
		
		//dos.close();
		
		}
		catch(Exception e)
		{
			System.out.println(e);
		}
		
		return n;
	}
	
	
	//static void readHash(int numOfHash, int hashSize, SimHash[] sh)
	static void readHash(int numOfHash, int hashSize, SimHash[] sh, String fName)
	{
		try
		{
			//FileInputStream fis = new FileInputStream("SimHash_"+Integer.toString(numOfHash)+".txt");
			FileInputStream fis = new FileInputStream(fName);
			DataInputStream dis = new DataInputStream(fis);
			
			for (int i=0; i<numOfHash; i++)
			{
				//System.out.println(i);
				sh[i] = new SimHash();
				sh[i].id = i;
				for (int j=0; j<hashSize; j++)
				{
					int val = dis.readInt();
					sh[i].hash[j] = val;
					//System.out.print("\t"+val);
					//if ((j+1)%8 == 0)
					//	System.out.println();
				}
				
			}
			
			dis.close();
			fis.close();
		}
		catch(Exception e)
		{
			
		}
	}
	
	static void readTestHash(int numOfHash, int hashSize, SimHash[] sh, String fName, String fName2)
	{
		try
		{
			//FileInputStream fis = new FileInputStream("SimHash_"+Integer.toString(numOfHash)+".txt");
			FileInputStream fis = new FileInputStream(fName);
			DataInputStream dis = new DataInputStream(fis);
			
			for (int i=0; i<3000; i++)
			{
				//System.out.println(i);
				sh[i] = new SimHash();
				sh[i].id = i;
				for (int j=0; j<hashSize; j++)
				{
					int val = dis.readInt();
					sh[i].hash[j] = val;
					//System.out.print("\t"+val);
					//if ((j+1)%8 == 0)
					//	System.out.println();
				}
				
			}
			
			fis = new FileInputStream(fName2);
			dis = new DataInputStream(fis);
			
			for (int i=3000; i<6000; i++)
			{
				//System.out.println(i);
				sh[i] = new SimHash();
				sh[i].id = i;
				for (int j=0; j<hashSize; j++)
				{
					int val = dis.readInt();
					sh[i].hash[j] = val;
					//System.out.print("\t"+val);
					//if ((j+1)%8 == 0)
					//	System.out.println();
				}
				
			}
			
			dis.close();
			fis.close();
		}
		catch(Exception e)
		{
			
		}
	}

}

