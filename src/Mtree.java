import java.io.*;
import java.util.*;

public class Mtree {

	//static boolean debug = false;
	static boolean debug = true;
	
	static int searchCount = 0;
	
	static int knn_id = -1;
	static int knn_dist = 1000;
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
				
		int hashSize = 128;
		//int hashSize = 2;
		
		//int numOfHash = 10;
		int numOfHash = 100;
		//int numOfHash = 10000;
		//int numOfHash = 20000;
		//int numOfHash = 30000;
		//int numOfHash = 40000;
		//int numOfHash = 50000;
		
		//int queryRad = 5;
		//int queryRad = 10;
		//int queryRad = 15;
		//int queryRad = 20;
		//int queryRad = 25;
		
		int queryRad = 10;
		//int queryRad = 20;
		//int queryRad = 30;
		//int queryRad = 40;
		//int queryRad = 50;
				
		SimHash[] sh = new SimHash[numOfHash];
		
		///////////////////////////////////////////////////////////
		// Read hashes
		///////////////////////////////////////////////////////////
		readHash(numOfHash, hashSize, sh);
		
		SimHash ns = new SimHash();
		for (int i=0; i<hashSize; i++)
		{
			ns.hash[i] = 1;
		}
		
		int min = 1000;
		int knn = -1;
		int dist = 0;
		
		long bs, be;
		bs = System.currentTimeMillis();
		
		// Find kNN by brute-force
		for (int i=0; i<numOfHash; i++)
		{
			//if (debug) System.out.println(i);
			//if (debug) sh[i].print();
			
			dist = ns.computeDistance(sh[i]);
			//System.out.println(i+":"+dist);
			
			if (dist < min)
			{
				min = dist;
				knn = i;
			}
		}
		be = System.currentTimeMillis();
		
		System.out.println("knn="+knn+":"+"dist="+min);
		System.out.println("Time(ms)="+(be-bs));
	
		////////////////////////////////////////////////////////////////
		// Create a tree
		////////////////////////////////////////////////////////////////
		long cs, ce;
		cs = System.currentTimeMillis();
		
		try
		{
			//FileOutputStream fos = new FileOutputStream("CreateLog.txt");
			//DataOutputStream dos = new DataOutputStream(fos);
			FileWriter fw = new FileWriter("CreateLog.txt");
			fw.write("CreateLog\n");
			fw.close();
			
			Mnode root = new Mnode();
			root = create(sh, numOfHash);
			
			//dos.close();
			//fos.close();
			//fw.close();
		
		
		ce = System.currentTimeMillis();
		System.out.println("Time to Create(ms) = "+(ce-cs));
		
		
		//////////////////////////////////////////////////////
		// Search a node
		//////////////////////////////////////////////////////
		long ss, se;
		ss = System.currentTimeMillis();
		
		
		
		
		//root.search(ns, rad);
		System.out.println("============================================");
		mTreeSearch(root, ns, queryRad);
		
		
		System.out.println("knn_id="+knn_id+":"+"knn_dist="+knn_dist);
		
		se = System.currentTimeMillis();
		System.out.println("Time to Search(ms) = "+(se-ss));
		
		System.out.println("searchCount="+searchCount);
		
		}
		catch(Exception e)
		{
			System.out.println(e);
		}
		
	}
	
	static void mTreeSearch(Mnode root, SimHash ns, int queryRad)
	{
		try
		{
			FileWriter fw = new FileWriter("CreateLog.txt", true);
			
		searchCount++;
		//System.out.println("searchCount = "+searchCount);
		
		//System.out.println();
		//if (debug) System.out.println(root.sh[0].id +":"
		//		+ root.sh[0].hash[0]+","+root.sh[0].hash[1]+":"+root.radius);
		
		// Compute the distance between the query and the node
		int dist = ns.computeDistance(root.sh[0]);
		//if (debug) System.out.println("Distance="+dist);
		//if (debug) System.out.println("Rad + Rq = "+(queryRad+root.radius));
		//if (debug) System.out.println("Rad - Rq = "+Math.abs(root.radius - queryRad));
		
		//knn_id = root.sh[0].id;
		//knn_dist = dist;
		if (dist < knn_dist)
		{
			knn_dist = dist;
			knn_id = root.sh[0].id;
			System.out.println("knn_id="+knn_id+":"+"knn_dist="+knn_dist);
		}
		
		
		if (root.count > 2)
		{
		
			// case 1 : When the query circle is outside the node circle
			if (dist > queryRad + root.radius)
			{
				if (debug) 
					//System.out.println("The query circle is outside the node circle:"
						//+ dist + ">" +(queryRad+root.radius));
					fw.write("The query circle is outside the node circle:"
						+ dist + ">" +(queryRad+root.radius)+"\n");
						
				if (debug) 
					//System.out.println("The left child of " 
						//+ root.sh[0].id  +" is prunned");
					fw.write("The left child of " 
						+ root.sh[0].id  +" is prunned"+"\n");
				
				fw.close();
			}
			else
			{	
				if (root.leftNode != null)
				{
					if (debug) 
						//System.out.println("The left child of " + root.sh[0].id  
							//+" is searched:"+root.leftNode.sh[0].id);
						fw.write("The left child of " + root.sh[0].id  
							+" is searched:"+root.leftNode.sh[0].id+"\n");
					
					fw.close();
					mTreeSearch(root.leftNode, ns, queryRad);
				}
				else
				{
					if (debug) 
						//System.out.println("\nThe left child of " 
							//	+ root.sh[0].id  +" is null");
						fw.write("\nThe left child of " 
								+ root.sh[0].id  +" is null"+"\n");
					if (debug) System.out.println("Count="+root.count);
					
					fw.close();
				}
			}
			
			// case 2 : When the query circle is inside the node circle
			fw = new FileWriter("CreateLog.txt", true);
			if (dist < Math.abs(root.radius - queryRad))
			{
				if (debug) 
					//System.out.println("The query circle is inside the node circle");
					fw.write("The query circle is inside the node circle"+"\n");
				if (debug) 
					//System.out.println("The right child of " + root.sh[0].id  +" is prunned"
						//+ dist +"<"+(root.radius-queryRad));
					fw.write("The right child of " + root.sh[0].id  +" is prunned"
							+ dist +"<"+(root.radius-queryRad)+"\n");
				
				fw.close();
			}
			else
			{
				if (root.rightNode != null)
				{
					if (debug) 
						//System.out.println("The right child of " + root.sh[0].id  
							//+" is searched:"+root.rightNode.sh[0].id);
						fw.write("The right child of " + root.sh[0].id  
							+" is searched:"+root.rightNode.sh[0].id+"\n");
					
					fw.close();
					mTreeSearch(root.rightNode, ns, queryRad);
				}
				else
				{
					if (debug) 
						//System.out.println("\nThe right child of " 
							//+ root.sh[0].id  +" is null");
						fw.write("\nThe right child of " 
								+ root.sh[0].id  +" is null"+"\n");	
					if (debug) System.out.println("Count="+root.count);
					
					fw.close();
				}
			}
					
			// case 3 : When the query circle is overlapped with the node circle
		
		}
		else
		{
			fw = new FileWriter("CreateLog.txt", true);
			
			if (debug) 
				//System.out.println("This is a leaf node");
				fw.write("The is a leaf node\n");
			for (int i=0; i<root.count; i++)
			{
				dist = ns.computeDistance(root.sh[i]);
				if (dist <= queryRad)
				{
					//if (debug) 
						//System.out.println(root.sh[i].id + 
							//"("+root.sh[i].hash[0]+","+root.sh[i].hash[1]  
								//	+")is within the query range:"+dist);
						fw.write(root.sh[i].id + 
							"("+root.sh[i].hash[0]+","+root.sh[i].hash[1]  
									+")is within the query range:"+dist+"\n");
						System.out.println("searchCount="+searchCount);
				}
				//else
					//if (debug) 
					//	System.out.println(root.sh[i].id + 
						//	"("+root.sh[i].hash[0]+","+root.sh[i].hash[1]  
							//		+")is NOT within the query range:"+dist);
				
				if (dist < knn_dist)
				{
					knn_dist = dist;
					knn_id = root.sh[i].id;
					System.out.println("knn_id="+knn_id+":"+"knn_dist="+knn_dist);
				}
			}
			fw.close();
		}
			
		}
		catch(Exception e)
		{
			
		}
	}
	
	
	static Mnode create(SimHash[] sh2, int numOfHash)
	{		
		Mnode n = new Mnode();
		n.sh = new SimHash[numOfHash];
		n.count = numOfHash;
			
		try
		{
		
		FileWriter dos = new FileWriter("CreateLog.txt", true);	
			
		for (int i=0; i<numOfHash; i++)
		{
			n.sh[i] = new SimHash();
			n.sh[i] = sh2[i];
			//if (debug) 
				//System.out.print("\t"+n.sh[i].id+"("+n.sh[i].hash[0]+","+n.sh[i].hash[1]+")");
				//dos.write("\t"+n.sh[i].id+"("+n.sh[i].hash[0]+","+n.sh[i].hash[1]+")");
		}
		if (debug) 
			//System.out.println();
			dos.write("node="+n.sh[0].id+"\n");
		
		int[] dist = new int[numOfHash];
		ArrayList al = new ArrayList();
		for (int i=0; i<numOfHash; i++)
		{
			dist[i] = n.sh[0].computeDistance(n.sh[i]);
			al.add(dist[i]);
		}
		al.sort(null);
		n.radius = (int)al.get(numOfHash/2);
		if (debug) 
			//System.out.println("rad="+n.radius);
			dos.write("rad="+n.radius+"\n");
		
		SimHash[] left = new SimHash[numOfHash];
		SimHash[] right = new SimHash[numOfHash];
		int leftCount = 0;
		int rightCount = 0;
		
		for (int i=1; i<numOfHash; i++)
		{
			if (dist[i] <= n.radius)
			{
				left[leftCount] = new SimHash();
				left[leftCount] = n.sh[i];
				left[leftCount].id = n.sh[i].id;
				leftCount++;
			}
			else
			{
				right[rightCount] = new SimHash();
				right[rightCount] = n.sh[i];
				right[rightCount].id = n.sh[i].id;
				rightCount++;
			}
		}
		if (debug) 
		{	//System.out.println(leftCount+":"+rightCount);
			dos.write("LeftCount="+leftCount+":RightCount="+rightCount+"\n");
			
			if (leftCount > 0) dos.write("LeftChild="+left[0].id+"\n");
			if (rightCount > 0) dos.write(":RightChild="+right[0].id+"\n");
		}
		
		if (leftCount >= 3)
		{
			if (debug) 
				//System.out.println("Creating left child");
				dos.write("Creating left child\n");
			
			dos.close();
			n.leftNode = create(left, leftCount);
		}
		else
		{
			if (debug) 
				//System.out.println("No Left Child:"+leftCount);
				dos.write("No Left Child:"+leftCount+"\n");
			
			Mnode lc = new Mnode();
			lc.sh = new SimHash[leftCount];
			
			for (int i=0; i<leftCount; i++)
			{
				lc.sh[i] = new SimHash();
				lc.sh[i] = left[i];
				//System.out.print("\t"+n.sh[i].id+"("+n.sh[i].hash[0]+","+n.sh[i].hash[1]+")");
			}
			n.leftNode = lc;
			lc.count = leftCount;
		
			dos.close();
		}
		
		
		
		dos = new FileWriter("CreateLog.txt", true);
		
		if (rightCount >= 3)
		{
			if (debug) 
				//System.out.println("Creating right child");
				dos.write("Creating right child\n");
			
			//dos.close();
			n.rightNode = create(right, rightCount);
		}
		else
		{
			if (debug) 
				//System.out.println("No Right Child:"+rightCount);
				dos.write("No Right Child:"+rightCount+"\n");
			Mnode rc = new Mnode();
			rc.sh = new SimHash[rightCount];
			
			for (int i=0; i<rightCount; i++)
			{
				rc.sh[i] = new SimHash();
				rc.sh[i] = right[i];
				//System.out.print("\t"+n.sh[i].id+"("+n.sh[i].hash[0]+","+n.sh[i].hash[1]+")");
			}
			n.rightNode = rc;
			rc.count = rightCount;
		}
		
		dos.close();
		
		}
		catch(Exception e)
		{
			System.out.println(e);
		}
		
		return n;
	}
	
	
	static void readHash(int numOfHash, int hashSize, SimHash[] sh)
	{
		try
		{
			FileInputStream fis = new FileInputStream("SimHash_"+Integer.toString(numOfHash)+".txt");
			DataInputStream dis = new DataInputStream(fis);
			
			for (int i=0; i<numOfHash; i++)
			{
				//System.out.println(i);
				sh[i] = new SimHash();
				sh[i].id = i;
				for (int j=0; j<hashSize; j++)
				{
					int val = dis.readInt();
					sh[i].hash[j] = val;
					//System.out.print("\t"+val);
					//if ((j+1)%8 == 0)
					//	System.out.println();
				}
				
			}
			
			dis.close();
			fis.close();
		}
		catch(Exception e)
		{
			
		}
	}

}
