import java.io.*;
import java.util.*;

public class Mtree4 {

	static boolean debug = false;
	//static boolean debug = true;
	
	static boolean search_debug = false;
	//static boolean search_debug = true;
	
	static int searchCount = 0;

	
	static int knn_id = -1;
	static int knn_dist = 1000;
	static int dk = 1000;
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int ACount = 0;
		int BCount = 0;
		int CCount = 0;
				
		int hashSize = 128;
				
		//int numOfHash = 10;
		//int numOfHash = 10000;
		//int numOfHash = 20000;
		//int numOfHash = 30000;
		//int numOfHash = 40000;
		//int numOfHash = 50000;
		
		//int numOfHash = 6000;
		int numOfHash = 12000;
		//int numOfHash = 18000;
		//int numOfHash = 24000;
		
		//int queryRad = 10;
		//int queryRad = 20;
		int queryRad = 10;
		//int queryRad = 40;
		//int queryRad = 50;
		
		//int fold = 1;
		
		SimHash[] sh = new SimHash[numOfHash];
		
		try
		{
			
			FileOutputStream fos0 = new FileOutputStream("exp_result_200302.txt");
			DataOutputStream dos0 = new DataOutputStream(fos0);
		
		//for (int fold=1; fold<=5; fold++) {
		for (int fold=1; fold<=1; fold++) {
			
			System.out.println("fold="+fold);
		
		///////////////////////////////////////////////////////////
		// Read hashes
		///////////////////////////////////////////////////////////
		//readHash(numOfHash, hashSize, sh);
		String fName = "SimHash_24000_"+fold+".txt";
		readHash(numOfHash, hashSize, sh, fName);
		
		SimHash ns = new SimHash();
		for (int i=0; i<hashSize; i++)
		{
			ns.hash[i] = 1;
		}
		
		
		//////////////////////////////////////////////////////////////
		// Find kNN by brute-force
		/////////////////////////////////////////////////////////////
		
		long bs, be;
		long total_bf_search_time = 0;
		//bs = System.currentTimeMillis();
		
		int bf_min = 100;
		int bf_knn = -1;
		int dist = 0;
		
		//System.out.println("===============================");
		for (int j=0; j<6000; j++)
		{
			bs = System.currentTimeMillis();
			for (int i=0; i<numOfHash; i++)
			{
				//if (debug) System.out.println(i);
				//if (debug) sh[i].print();
				
				dist = ns.computeDistance(sh[i]);
				//System.out.println(i+":"+dist);
				
				if (dist < bf_min)
				{
					bf_min = dist;
					bf_knn = i;
				}
			}
			be = System.currentTimeMillis();
			total_bf_search_time += be - bs;
		}
		//be = System.currentTimeMillis();
		
		//System.out.println("bf_knn="+bf_knn+":"+"bf_min="+bf_min);
		System.out.println("Time(ms)="+total_bf_search_time);
		
		
		/*if (knn_id != bf_knn && knn_dist != bf_min)
		{
			System.out.println("knn is different from bf_knn");
			System.out.printf("knn_id=%d, bf_knn=%d\n", knn_id, bf_knn);
			System.out.printf("knn_dist=%d, bf_min=%d\n", knn_dist, bf_min);
			//wrongKNN++;
		}
		else
		{
			System.out.println("knn is same with bf_knn");
			System.out.printf("knn_id=%d, bf_knn=%d\n", knn_id, bf_knn);
			System.out.printf("knn_dist=%d, bf_min=%d\n", knn_dist, bf_min);
		}*/	
	
		
	
		////////////////////////////////////////////////////////////////
		// Create a tree
		////////////////////////////////////////////////////////////////
		long cs, ce;
		cs = System.currentTimeMillis();
		
		//try
		//{
			//FileOutputStream fos = new FileOutputStream("CreateLog.txt");
			//DataOutputStream dos = new DataOutputStream(fos);
			//FileWriter fw = new FileWriter("CreateLog.txt");
			//fw.write("CreateLog\n");
			//fw.close();
			
			//numOfHash = 1000;	// For debug
			//numOfHash = 2000;	// For debug
			//numOfHash = 3000;	// For debug
			//numOfHash = 4000;	// For debug
			//numOfHash = 5000;	// For debug
			
			Mnode root = new Mnode();
			root = create(sh, numOfHash);
			
			//dos.close();
			//fos.close();
			//fw.close();
		
		
		ce = System.currentTimeMillis();
		System.out.println("Time to Create(ms) = "+(ce-cs));
		
		
		
		
		//////////////////////////////////////////////////////
		// Test (Malicious File)
		//////////////////////////////////////////////////////
		
		FileInputStream fis = new FileInputStream("Malicious_SimHash_3000_"+fold+".txt");
		//FileInputStream fis = new FileInputStream("Normal_SimHash_3000"+fold+".txt");
		DataInputStream dis = new DataInputStream(fis);
		
		int totalSearchCount = 0;
		int tp = 0;
		int wrongKNN = 0;
		long ss, se;
		
		long total_search_time = 0;
		for (int j=0; j<3000; j++)
		//for (int j=0; j<1; j++)
		{
			//System.out.println("============================================");
			//System.out.println(j+"th search");
			ns = new SimHash();
			
			// For debug
			//for (int i=0; i<hashSize; i++)
			//	dis.readInt();
			
			for (int i=0; i<hashSize; i++)
			{
				//ns.hash[i] = 1;
				ns.hash[i] = dis.readInt();
				//System.out.print(ns.hash[i]);
			}
			//System.out.println();
						
			//root.search(ns, rad);
			
			
			
			
			searchCount = 0;
			knn_dist = 1000;
			
			ss = System.currentTimeMillis();
			
			mTreeSearch(root, ns, queryRad);
			
			se = System.currentTimeMillis();
			
			//System.out.println("============================================");
			//System.out.println("knn_id="+knn_id+":"+"knn_dist="+knn_dist);
			
			//if (knn != knn_id)
			//{
				//System.out.printf("%d is not same with %d\n", knn, knn_id);
				//System.out.printf("%d is not same with %d\n", min, knn_dist);
			//}
			
			if (knn_id < 12000)
			//if (knn_id > 12000)
				{BCount++;}
			else if (knn_id > 12000) 
			    {ACount++;}
			else CCount++;
			
			//se = System.currentTimeMillis();
			//System.out.println("Time to Search(ms) = "+(se-ss));
			total_search_time += se-ss;
			
			//System.out.println("searchCount="+searchCount);
			totalSearchCount += searchCount;
			
			
			
					
			
			
			
		} // for j
		//System.out.println("Total Search Time for 3000 malicious files (ms)="+total_search_time);
		
		
		//System.out.println("===============================");
		//System.out.println("TP="+tp);
		//System.out.println("Avg of SearchCount="+(totalSearchCount/3000));
		//System.out.printf("wrongKNN=%d\n", wrongKNN);
		
		//dos0.writeUTF("TP="+tp);
		//dos0.writeUTF("SearchCount="+(totalSearchCount/3000));
		//dos0.writeUTF("wrongKNN="+wrongKNN);
		
		
		///////////////////////////////////////////////
		// Normal File
		///////////////////////////////////////////////
		//long ss, se;
		//ss = System.currentTimeMillis();
		
		
		// Test
		//FileInputStream fis = new FileInputStream("Malicious_SimHash_3000"+fold+".txt");
		fis = new FileInputStream("Normal_SimHash_3000_"+fold+".txt");
		dis = new DataInputStream(fis);
		
		totalSearchCount = 0;
		tp = 0;
		wrongKNN = 0;
		
		
		
		for (int j=0; j<3000; j++)
		//for (int j=0; j<2; j++)
		{
			//System.out.println("============================================");
			//System.out.println(j+"th search");
			ns = new SimHash();
			
			// For debug
			//for (int i=0; i<hashSize; i++)
			//	dis.readInt();
			
			for (int i=0; i<hashSize; i++)
			{
				//ns.hash[i] = 1;
				ns.hash[i] = dis.readInt();
				//System.out.print(ns.hash[i]);
			}
			//System.out.println();
						
			//root.search(ns, rad);
			
			
			searchCount = 0;
			knn_dist = 1000;
			
			ss = System.currentTimeMillis();
			mTreeSearch(root, ns, queryRad);
			se = System.currentTimeMillis();
			
			
			//System.out.println("============================================");
			//System.out.println("knn_id="+knn_id+":"+"knn_dist="+knn_dist);
			
			//if (knn != knn_id)
			{
				//System.out.printf("%d is not same with %d\n", knn, knn_id);
				//System.out.printf("%d is not same with %d\n", min, knn_dist);
			}
			
			if (knn_id > 12000)
				//if (knn_id > 12000)
					{ACount++;}
				else if (knn_id < 12000) 
				    {BCount++;}
				else CCount++;
			
			total_search_time += se-ss;
			//se = System.currentTimeMillis();
			//System.out.println("Time to Search(ms) = "+(se-ss));
			
			//System.out.println("searchCount="+searchCount);
			totalSearchCount += searchCount;
			
			
			
					
			
			
			
		} // for j
		System.out.println("Total Search Time(ms)="+total_search_time);
		System.out.println("A(Á¤»ó)="+ACount);
		System.out.println("B(¾Ç¼º)="+BCount);
		System.out.println("C(Á¤»óX¾Ç¼ºX)="+CCount);
		
		
		} // for fold
		
		
		}
		catch(Exception e)
		{
			System.out.println(e);
		}
		
		
		
	}

	
	
	
	
	
	static void mTreeSearch(Mnode root, SimHash ns, int queryRad)
	{
		try
		{
			searchCount++;
			
			//FileWriter fw = new FileWriter("CreateLog.txt", true);
			
			// Compute the distance between root and q
			int dist = ns.computeDistance(root.sh[0]);
			//if (search_debug) 
				//System.out.printf("\nDistance between q and node %d=%d, %d\n", 
					//	root.sh[0].id, dist, knn_dist);
			
			if (dist < knn_dist)
			{
				knn_dist = dist;
				knn_id = root.sh[0].id;
				//if (search_debug) System.out.println(knn_id+" is NN:"+knn_dist);
			}
			
			// if min_dist(child, q) > knn_dist, the sub-tree is prunned
			// 1) Left Child
			if (root.leftNode != null)
			{
				/*
				// Compute the distance between the left child and q
				int left_dist = ns.computeDistance(root.leftNode.sh[0]);
				
				int min_dist = Math.max(left_dist - root.leftNode.radius, 0);
				if ( min_dist > knn_dist )
				{
					if (search_debug) 
					{
						System.out.printf("The left child %d is prunned\n", root.leftNode.sh[0].id);
						System.out.printf("min_dist=%d > knn_dist=%d\n", min_dist, knn_dist);
						System.out.printf("left_dist=%d, root.leftNode.radius=%d\n", left_dist, root.leftNode.radius);
					}
				}
				else
					mTreeSearch(root.leftNode, ns, queryRad);
				*/
				
				//int min_dist = Math.max(dist - root.radius, 0);
				int left_dist = ns.computeDistance(root.leftNode.sh[0]);
				int min_dist = Math.max(left_dist - root.leftNode.radius, 0);
				if (min_dist > knn_dist)
				{
					//if (search_debug) 
					//{
						//System.out.printf("\nThe left child %d is prunned\n", root.leftNode.sh[0].id);
						//System.out.printf("left_dist=%d, left_rad=%d\n",left_dist, root.leftNode.radius);
						//System.out.printf("min_dist=%d > knn_dist=%d\n", min_dist, knn_dist);
						
					//}
				}
				else
				{
					//if (search_debug)
					//{
					  //System.out.printf("left_dist=%d, left_rad=%d\n",left_dist, root.leftNode.radius);
					  //System.out.printf("min_dist=%d < knn_dist=%d\n", min_dist, knn_dist);
					//}
					mTreeSearch(root.leftNode, ns, queryRad);
				}
			}
			
			
			// 2) Right Child
			if (root.rightNode != null)
			{
				// Compute the distance between the right child and q
				int right_dist = ns.computeDistance(root.rightNode.sh[0]);
				
				int min_dist = Math.max(right_dist - root.rightNode.radius, 0);
				if ( min_dist > knn_dist )
				{
					//if (search_debug) 
					//{
						//System.out.printf("\nThe right child %d is prunned\n", root.rightNode.sh[0].id);
						//System.out.printf("right_dist=%d, right_rad=%d\n",right_dist, root.rightNode.radius);
						//System.out.printf("min_dist=%d > knn_dist=%d\n", min_dist, knn_dist);
					//}
				}
				else
				{
					//if (search_debug)
					//{
					  //System.out.printf("right_dist=%d, right_rad=%d\n",right_dist, root.rightNode.radius);
					  //System.out.printf("min_dist=%d < knn_dist=%d\n", min_dist, knn_dist);
					//}
					mTreeSearch(root.rightNode, ns, queryRad);
				}
			}
			
			// 3) leaf node
			if (root.leftNode == null && root.rightNode == null)
			{
				//System.out.printf("\nThis is a leaf node=%d\n", root.count);
				for (int i=1; i<root.count; i++)
				{
					// Compute the distance between root and q
					dist = ns.computeDistance(root.sh[i]);
					//if (search_debug) 
					//	System.out.printf("Leaf:Distance between q and node %d=%d, %d\n", 
					//			root.sh[i].id, dist, knn_dist);
					
					if (dist < knn_dist)
					{
						knn_dist = dist;
						knn_id = root.sh[i].id;
						//if (search_debug) System.out.println(knn_id+" is NN:"+knn_dist);
					}
				}
			}
			
			//fw.close();
			
		}
		catch(Exception e)
		{
			
		}
	}
	
	
	static Mnode create(SimHash[] sh2, int numOfHash)
	{		
		Mnode n = new Mnode();
		n.sh = new SimHash[numOfHash];
		n.count = numOfHash;
			
		try
		{
		
		//FileWriter dos = new FileWriter("CreateLog.txt", true);	
			
		for (int i=0; i<numOfHash; i++)
		{
			n.sh[i] = new SimHash();
			n.sh[i] = sh2[i];
			//if (debug) 
				//System.out.print("\t"+n.sh[i].id+"("+n.sh[i].hash[0]+","+n.sh[i].hash[1]+")");
				//dos.write("\t"+n.sh[i].id+"("+n.sh[i].hash[0]+","+n.sh[i].hash[1]+")");
		}
		//if (debug) 
			//System.out.println();
			//dos.write("\nnode="+n.sh[0].id+"th\n");
		
		int[] dist = new int[numOfHash];
		ArrayList al = new ArrayList();
		int total = 0;
		for (int i=0; i<numOfHash; i++)
		{
			dist[i] = n.sh[0].computeDistance(n.sh[i]);
			al.add(dist[i]);
			total += dist[i];
		}
		al.sort(null);
		n.radius = (int)al.get(numOfHash/2);
		
		// When the radius is zero, we set the average to the raduis instead of the median
		if (n.radius == 0)
		{
			n.radius = total / numOfHash;
		}
		
		//if (debug) 
		//{
			//System.out.println("rad="+n.radius);
			//dos.write("rad="+n.radius+"\n");
			
			//for (int i=0; i<numOfHash; i++)
				//dos.write(al.get(i)+", ");
			//dos.write("\n");		
		//}
		
		SimHash[] left = new SimHash[numOfHash];
		SimHash[] right = new SimHash[numOfHash];
		int leftCount = 0;
		int rightCount = 0;
		
		for (int i=1; i<numOfHash; i++)
		{
			if (dist[i] <= n.radius)
			{
				left[leftCount] = new SimHash();
				left[leftCount] = n.sh[i];
				left[leftCount].id = n.sh[i].id;
				leftCount++;
			}
			else
			{
				right[rightCount] = new SimHash();
				right[rightCount] = n.sh[i];
				right[rightCount].id = n.sh[i].id;
				rightCount++;
			}
		}
		if (debug) 
		{	//System.out.println(leftCount+":"+rightCount);
			//dos.write("LeftCount="+leftCount+":RightCount="+rightCount+"\n");
			
			//if (leftCount > 0) dos.write("LeftChild="+left[0].id+"\n");
			//if (rightCount > 0) dos.write(":RightChild="+right[0].id+"\n");
		}
		
		///////////////////////////////////////////////////////
		// Left Child
		///////////////////////////////////////////////////////
		if (leftCount >= 3)
		{
			//if (debug) 
				//System.out.println("Creating left child");
				//dos.write("\nCreating left child\n");
			
			//dos.close();
			n.leftNode = create(left, leftCount);
		}
		else
		{
			//if (debug) 
				//System.out.println("No Left Child:"+leftCount);
				//dos.write("No Left Child:"+leftCount+"\n");
			
			Mnode lc = new Mnode();
			lc.sh = new SimHash[leftCount];
			
			for (int i=0; i<leftCount; i++)
			{
				lc.sh[i] = new SimHash();
				lc.sh[i] = left[i];
				//System.out.print("\t"+n.sh[i].id+"("+n.sh[i].hash[0]+","+n.sh[i].hash[1]+")");
				//dos.write(i+":"+lc.sh[i].id+"\n");
			}
			n.leftNode = lc;
			lc.count = leftCount;
			
			// Leaf node's radius
			if (leftCount == 2)
			{
				lc.radius = lc.sh[0].computeDistance(lc.sh[1]); 
				//dos.write("Leaf node radius="+lc.radius+"\n");
			}
		
			//dos.close();
		}
		//dos.close();
		
		
		//dos = new FileWriter("CreateLog.txt", true);
		
		// Right Child
		if (rightCount >= 3)
		{
			//if (debug) 
				//System.out.println("Creating right child");
				//dos.write("\nCreating right child\n");
			
			//dos.close();
			n.rightNode = create(right, rightCount);
		}
		else
		{
			//if (debug) 
				//System.out.println("No Right Child:"+rightCount);
				//dos.write("No Right Child:"+rightCount+"\n");
			Mnode rc = new Mnode();
			rc.sh = new SimHash[rightCount];
			
			for (int i=0; i<rightCount; i++)
			{
				rc.sh[i] = new SimHash();
				rc.sh[i] = right[i];
				//System.out.print("\t"+n.sh[i].id+"("+n.sh[i].hash[0]+","+n.sh[i].hash[1]+")");
				//dos.write(i+":"+rc.sh[i].id+"\n");
			}
			n.rightNode = rc;
			rc.count = rightCount;
			
			// Leaf node's radius
			if (rightCount == 2)
			{
				rc.radius = rc.sh[0].computeDistance(rc.sh[1]); 
				//dos.write("Leaf node radius="+rc.radius+"\n");
			}
		}
		
		
		//dos.close();
		
		}
		catch(Exception e)
		{
			System.out.println(e);
		}
		
		return n;
	}
	
	
	//static void readHash(int numOfHash, int hashSize, SimHash[] sh)
	static void readHash(int numOfHash, int hashSize, SimHash[] sh, String fName)
	{
		try
		{
			//FileInputStream fis = new FileInputStream("SimHash_"+Integer.toString(numOfHash)+".txt");
			FileInputStream fis = new FileInputStream(fName);
			DataInputStream dis = new DataInputStream(fis);
			
			for (int i=0; i<numOfHash; i++)
			{
				//System.out.println(i);
				sh[i] = new SimHash();
				sh[i].id = i;
				for (int j=0; j<hashSize; j++)
				{
					int val = dis.readInt();
					sh[i].hash[j] = val;
					//System.out.print("\t"+val);
					//if ((j+1)%8 == 0)
					//	System.out.println();
				}
				
			}
			
			dis.close();
			fis.close();
		}
		catch(Exception e)
		{
			
		}
	}

}
