import java.io.*;
import java.util.*;

public class Mtree5 {

   static boolean debug = false;
   //static boolean debug = true;
   
   static boolean search_debug = false;
   //static boolean search_debug = true;
   
   static int searchCount = 0;
   
   static int knn_id = -1;
   
   static int knn_dist = 1000;
   //static int knn_dist = 100;
   //static int knn_dist = 50;
   
   static int dk = 1000;
   
   static int left_prune_count = 0;
   static int right_prune_count = 0;
 
   
   public static void main(String[] args) {
      // TODO Auto-generated method stub
            
      int hashSize = 128;
      
      //int numOfHash = 10;
      //int numOfHash = 20;
      //int numOfHash = 100;
      
      //int numOfHash = 6000;
      //int numOfHash = 12000;
      int numOfHash = 12000;               //테스트데이터 해당값 넣기
      //int numOfHash = 24000;
      
      //int queryRad = 10;
      //int queryRad = 20;
      int queryRad = 30;
      //int queryRad = 40;
      //int queryRad = 50;
      
      SimHash[] sh = new SimHash[numOfHash];
      SimHash[] query = new SimHash[12000]; //test데이터 해당값 넣기
      
      try
      {
         
         //FileOutputStream fos0 = new FileOutputStream("sh_200226.txt"); // sh_200226 은 tlsh파일이며 fold를 통해 테스트,학습데이터의 개수를 임의로 구성해주고 끝난다. 쓰면안됨 
    	  FileOutputStream fos0 = new FileOutputStream("exp_result_200302.txt");
         DataOutputStream dos0 = new DataOutputStream(fos0);
          
      
         int avg_search_count=0;
         long avg_search_time=0;
         long avg_create_time=0;
          
         //for (int fold=1; fold<=5; fold++) {
         for (int fold=1; fold<=1; fold++) {
            
            System.out.println("fold="+fold);
            
            // init
            searchCount = 0;
            knn_dist = 1000;
         
            ///////////////////////////////////////////////////////////
            // Read hashes
            ///////////////////////////////////////////////////////////
            System.out.println("Read hashes");
            //readHash(numOfHash, hashSize, sh);
            //String fName = "Train_"+fold+".txt";  // 15000개
            //String fName = "Train_15000_"+fold+".txt";  // 15000개
            String fName = "SimHash_24000_"+fold+".txt";
            
            long read_st = System.currentTimeMillis();
            readHash(numOfHash, hashSize, sh, fName);
            long read_et = System.currentTimeMillis();
            //System.out.println("Time to Read Train Data="+(read_et-read_st));
            
            //analyzeHash(numOfHash, hashSize, sh);
            
            
            SimHash ns = new SimHash();
            for (int i=0; i<hashSize; i++)
            {
               ns.hash[i] = 1;
            }
         
            ////////////////////////////////////////////////////////////////
            // Create a tree
            ////////////////////////////////////////////////////////////////
            System.out.println("Create a tree");
            long cs, ce;
            cs = System.currentTimeMillis();
            
            //try
            //{
               //FileOutputStream fos = new FileOutputStream("CreateLog.txt");
               //DataOutputStream dos = new DataOutputStream(fos);
               //FileWriter fw = new FileWriter("CreateLog.txt");
               //fw.write("CreateLog\n");
               //fw.close();
               
               Mnode root = new Mnode();
               root = create(sh, numOfHash);
               
               //dos.close();
               //fos.close();
               //fw.close();
            
            ce = System.currentTimeMillis();
            System.out.println("Time to Create(ms) = "+(ce-cs));
            avg_create_time += ce - cs;
            
         
            //////////////////////////////////////////////////////
            // Test (Malicious File + Normal File)
            //////////////////////////////////////////////////////
            //System.out.println("Search Test");
            System.out.println("test");
            
            //String malTest = "Mal_7500_"+fold+".txt";
            String malTest = "Malicious_SimHash_6000_"+fold+".txt";
            //String normalTest = "Nor_7500_"+fold+".txt";
            String normalTest = "Normal_SimHash_6000_"+fold+".txt";
            
            long read_st2 = System.currentTimeMillis();
            //readTestHash(6000, hashSize, query, malTest, normalTest);
            //readTestHash(15000, hashSize, query, malTest, normalTest);
            
            readTestHash(12000, hashSize, query, malTest, normalTest);
            
            long read_et2 = System.currentTimeMillis();
            //System.out.println("Time to Read Test Data="+(read_et2-read_st2));
            
            int tp = 0;
            int wrongKNN = 0;
            long ss, se;
            int totalSearchCount = 0;
            float total_search_time = 0;
            
            int A = 0;
            int B=0;
            int C=0;
           
            //for (int j=0; j<1; j++) {
            //for (int j=0; j<6000; j++) {
            for (int j=0; j<12000; j++) {
               
               //System.out.println(j);
               //query[j].print();
               
               searchCount = 0;
               knn_dist = 1000;
           
               ns = query[j];
               ss = System.currentTimeMillis();
               //mTreeSearch(root, ns, queryRad);
               //modifiedSearch(root, ns, queryRad);
               modifiedSearch(root, ns, queryRad);
               se = System.currentTimeMillis();
               
               if (knn_id < 12000 && j<8000) {A++;}
               else if (knn_id >= 12000 && j>=8000) {B++;}
               else {C++;}   
                           
               total_search_time += se-ss;
               totalSearchCount += searchCount;
            
               if ((j+1)%1000 == 0)
                  System.out.println((j+1)+":Elapsed Search Time(ms)="+total_search_time);
                        
            } // for j
           // System.out.println("악성"+A+"정상"+B+"그외"+C);
            
           // System.out.println("totalSearchCount="+totalSearchCount/6000);
           // System.out.println("Total Search Time(ms)="+total_search_time);
            //System.out.println("left_prune_count="+left_prune_count/6000);
            //System.out.println("right_prune_count="+right_prune_count/6000);
            
            
           // avg_search_count += totalSearchCount/6000;
            //avg_search_time += total_search_time;
            
            System.out.println("평균 개당 검색시간(ms) = "+ (float) total_search_time/numOfHash);
         } // for fold
      
         //System.out.println("\navg time="+avg_search_time/5);
         //System.out.println("avg count="+avg_search_count/5);
        // System.out.println("avg create time="+avg_create_time/5);
      
      }
      catch(Exception e)
      {
         System.out.println(e);
      }
   
   }

   
   static void modifiedSearch(Mnode root, SimHash ns, int queryRad)
   {
      //System.out.println("modifiedSearch():"+root.sh[0].id);
      //try
      //{
         searchCount++;
         //FileWriter fw = new FileWriter("CreateLog.txt", true);
         
         // Compute the distance between root and q
         int dist = ns.computeDistance(root.sh[0]);
         
         if (dist < knn_dist) {
            knn_dist = dist;
            knn_id = root.sh[0].id;
            //if (search_debug) System.out.println(knn_id+" is NN:"+knn_dist);
         }
         
         // 1) Left Child
         // if dist(q,p) >= r(p) + knn_dist, prune the left child
         if (root.leftNode != null) {
            if (dist >= root.radius + knn_dist) {
               //left_prune_count++;
            }
            else {
            //if (dist < root.radius + knn_dist) {
               //if (search_debug) 
                  //System.out.println("left child:"+root.leftNode.sh[0].id);
               modifiedSearch(root.leftNode, ns, queryRad);
            }
         }
         
         // 2) Right Child
         // if dist(q,p) + knn_dist <= r(p), prune the right child
         if (root.rightNode != null) {
            if ( dist + knn_dist <= root.radius ) {
               //right_prune_count++;
            }
            else {
            //if (dist + knn_dist > root.radius) {
               //if (search_debug) 
                  //System.out.println("right child:"+root.rightNode.sh[0].id);
               modifiedSearch(root.rightNode, ns, queryRad);
            }
         }
         
         // 3) leaf node
         if (root.leftNode == null && root.rightNode == null) {
            //System.out.printf("\nThis is a leaf node=%d\n", root.count);
            for (int i=1; i<root.count; i++) {
               // Compute the distance between root and q
               dist = ns.computeDistance(root.sh[i]);
               //System.out.println(i+":"+dist);
               
               if (dist < knn_dist) {
                  knn_dist = dist;
                  knn_id = root.sh[i].id;
                  //if (search_debug) System.out.println(knn_id+" is NN:"+knn_dist);
               }
            }
         }
         //fw.close();
      //}
      //catch(Exception e){
      //}
   }
   
   
   
   static void mTreeSearch(Mnode root, SimHash ns, int queryRad)
   {
      try
      {
         searchCount++;
         
         //FileWriter fw = new FileWriter("CreateLog.txt", true);
         
         // Compute the distance between root and q
         int dist = ns.computeDistance(root.sh[0]);
         
         
         
         if (dist < knn_dist)
         {
            knn_dist = dist;
            knn_id = root.sh[0].id;
            //if (search_debug) System.out.println(knn_id+" is NN:"+knn_dist);
         }
         
         // if min_dist(child, q) > knn_dist, the sub-tree is prunned
         // 1) Left Child
         if (root.leftNode != null)
         {
               
            //int min_dist = Math.max(dist - root.radius, 0);
            int left_dist = ns.computeDistance(root.leftNode.sh[0]);
            int min_dist = Math.max(left_dist - root.leftNode.radius, 0);
            if (min_dist > knn_dist)
            {
               
            }
            else
            {
               mTreeSearch(root.leftNode, ns, queryRad);
            }
         }
         
         
         // 2) Right Child
         if (root.rightNode != null)
         {
            // Compute the distance between the right child and q
            int right_dist = ns.computeDistance(root.rightNode.sh[0]);
            
            int min_dist = Math.max(right_dist - root.rightNode.radius, 0);
            if ( min_dist > knn_dist )
            {
               
            }
            else
            {
               mTreeSearch(root.rightNode, ns, queryRad);
            }
         }
         
         // 3) leaf node
         if (root.leftNode == null && root.rightNode == null)
         {
            //System.out.printf("\nThis is a leaf node=%d\n", root.count);
            for (int i=1; i<root.count; i++)
            {
               // Compute the distance between root and q
               dist = ns.computeDistance(root.sh[i]);
               
               if (dist < knn_dist)
               {
                  knn_dist = dist;
                  knn_id = root.sh[i].id;
                  //if (search_debug) System.out.println(knn_id+" is NN:"+knn_dist);
               }
            }
         }
         
         //fw.close();
         
      }
      catch(Exception e)
      {
         
      }
   }
   
   
   static Mnode create(SimHash[] sh2, int numOfHash)
   {  
	  //System.out.println("create:"+numOfHash); 
	   
      Mnode n = new Mnode();
      n.sh = new SimHash[numOfHash];
      n.count = numOfHash;
         
      try{
         //FileWriter dos = new FileWriter("CreateLog.txt", true);               
         for (int i=0; i<numOfHash; i++) {
            n.sh[i] = new SimHash();
            n.sh[i] = sh2[i];
            if (debug) 
               System.out.print("\t"+n.sh[i].id+"("+n.sh[i].hash[0]+","+n.sh[i].hash[1]+")");
               //dos.write("\t"+n.sh[i].id+"("+n.sh[i].hash[0]+","+n.sh[i].hash[1]+")");
         }
         if (debug) 
            System.out.println();
            //dos.write("\nnode="+n.sh[0].id+"th\n");
         
         
         
         boolean vp_selection_flag = true;
         //boolean vp_selection_flag = false;
         
         // Select a vantage point
         // Set a point which is closest to the average of the point to a vantage point
         if (vp_selection_flag) {
            // 1) compute the average
            SimHash avg = new SimHash();
            for (int i=0; i<128; i++) {
               avg.hash[i] = 0;
               for (int j=0; j<numOfHash; j++) {
                  avg.hash[i] += n.sh[j].hash[i];
               }
               avg.hash[i] = avg.hash[i] / numOfHash;
            }
            
            // 2) find a point which is closest to the average
            int min = 10000;
            int pos = -1;
            for (int i=0; i<numOfHash; i++) {
               int dist = avg.computeDistance(n.sh[i]);
               if (dist < min) {
                  min = dist;
                  pos = i;
               }
            }
            
            // 3) change sh[0] with sh[pos];
            //n.sh[0].change(n.sh[pos]);
            //System.out.println("min="+min+",pos="+pos);            
         }// if
         
         
                  
         int[] dist = new int[numOfHash];
         ArrayList<Integer> al = new ArrayList<Integer>();
         int total = 0;
         for (int i=0; i<numOfHash; i++) {
            dist[i] = n.sh[0].computeDistance(n.sh[i]);
            al.add(dist[i]);
            total += dist[i];
         }
         al.sort(null);
         
         n.radius = (int)al.get(numOfHash/2);
         
         // When the radius is zero, we set the average to the radius instead of the median
         if (n.radius == 0)
         {
            n.radius = total / numOfHash;
         }
         //System.out.println("rad="+n.radius);
         
         if (debug) {
            //System.out.println("rad="+n.radius);
            //dos.write("rad="+n.radius+"\n");
            
            //for (int i=0; i<numOfHash; i++)
               //dos.write(al.get(i)+", ");
            //dos.write("\n");      
         }
         
         SimHash[] left = new SimHash[numOfHash];
         SimHash[] right = new SimHash[numOfHash];
         int leftCount = 0;
         int rightCount = 0;
         
         for (int i=1; i<numOfHash; i++) {
            if (dist[i] <= n.radius) {
               left[leftCount] = new SimHash();
               left[leftCount] = n.sh[i];
               left[leftCount].id = n.sh[i].id;
               leftCount++;
            }
            else {
               right[rightCount] = new SimHash();
               right[rightCount] = n.sh[i];
               right[rightCount].id = n.sh[i].id;
               rightCount++;
            }
         }
         if (debug) {   
            System.out.println(leftCount+":"+rightCount);
            //dos.write("LeftCount="+leftCount+":RightCount="+rightCount+"\n");
            
            //if (leftCount > 0) dos.write("LeftChild="+left[0].id+"\n");
            //if (rightCount > 0) dos.write(":RightChild="+right[0].id+"\n");
         }
         
         ///////////////////////////////////////////////////////
         // Left Child
         ///////////////////////////////////////////////////////
         if (leftCount >= 3)
         //if (leftCount >= 2)
         {
            if (debug) 
               System.out.println("Creating left child");
               //dos.write("\nCreating left child\n");
            
            //dos.close();
            //n.leftNode = create(left, leftCount);
         }
         //else if (leftCount == 1)
         else if (leftCount >= 1)
         {
            if (debug) 
               System.out.println("No Left Child:"+leftCount);
               //dos.write("No Left Child:"+leftCount+"\n");
            
            Mnode lc = new Mnode();
            lc.sh = new SimHash[leftCount];
            
            for (int i=0; i<leftCount; i++)
            {
               lc.sh[i] = new SimHash();
               lc.sh[i] = left[i];
               //System.out.print("\t"+n.sh[i].id+"("+n.sh[i].hash[0]+","+n.sh[i].hash[1]+")");
               //dos.write(i+":"+lc.sh[i].id+"\n");
            }
            n.leftNode = lc;
            lc.count = leftCount;
            
            // Leaf node's radius
            if (leftCount == 2)
            {
               lc.radius = lc.sh[0].computeDistance(lc.sh[1]); 
               //dos.write("Leaf node radius="+lc.radius+"\n");
            }
         
            //dos.close();
         }
         else {
            n.leftNode = null;
         }
         //dos.close();
         
         
         //dos = new FileWriter("CreateLog.txt", true);
         
         // Right Child
         if (rightCount >= 3)
         //if (rightCount >= 2)
         {
            if (debug) 
               System.out.println("Creating right child");
               //dos.write("\nCreating right child\n");
            
            //dos.close();
            n.rightNode = create(right, rightCount);
         }
         //else if (rightCount == 1)
         else if (rightCount >= 1)
         {
            if (debug) 
               System.out.println("No Right Child:"+rightCount);
               //dos.write("No Right Child:"+rightCount+"\n");
            Mnode rc = new Mnode();
            rc.sh = new SimHash[rightCount];
            
            for (int i=0; i<rightCount; i++)
            {
               rc.sh[i] = new SimHash();
               rc.sh[i] = right[i];
               //System.out.print("\t"+n.sh[i].id+"("+n.sh[i].hash[0]+","+n.sh[i].hash[1]+")");
               //dos.write(i+":"+rc.sh[i].id+"\n");
            }
            n.rightNode = rc;
            rc.count = rightCount;
            
            // Leaf node's radius
            if (rightCount == 2)
            {
               rc.radius = rc.sh[0].computeDistance(rc.sh[1]); 
               //dos.write("Leaf node radius="+rc.radius+"\n");
            }
         }
         else {
            n.rightNode = null;
         }
            
         
         
         //dos.close();
      
      }
      catch(Exception e)
      {
         System.out.println(e);
      }
      
      return n;
   }
   
   
   
   
   //static void readHash(int numOfHash, int hashSize, SimHash[] sh)
   static void readHash(int numOfHash, int hashSize, SimHash[] sh, String fName)
   {
      try
      {
         //FileInputStream fis = new FileInputStream("SimHash_"+Integer.toString(numOfHash)+".txt");
         FileInputStream fis = new FileInputStream(fName);
         DataInputStream dis = new DataInputStream(fis);
         
         
         //for (int i=0; i<12000-numOfHash/2; i++)
         for (int i=0; i<15000; i++)
         {
            //System.out.println(i);
               sh[i]=new SimHash();
               sh[i].id=i;
            for (int j=0; j<hashSize; j++)
            {
               int val = dis.readInt();
               //sh[i].hash[j] = val;
               //System.out.print("\t"+val);
               //if ((j+1)%8 == 0)
               //   System.out.println();
            }
            
         }
         
         //for (int i=12000-numOfHash/2; i<12000+numOfHash/2; i++)
         for (int i=15000; i<30000; i++)
         {
           // System.out.println(i);
            //int pos = i - (12000 - numOfHash/2);
            int pos = i;
        	sh[pos] = new SimHash();
            sh[pos].id = i;
            
            for (int j=0; j<hashSize; j++)
            {
               int val = dis.readInt();
               sh[pos].hash[j] = val;
               //System.out.print("\t"+val);
               //if ((j+1)%8 == 0)
               //   System.out.println();
            }
            
         }
         
         /*
         for (int i=0; i<numOfHash; i++)
         {
            //System.out.println(i);
            sh[i] = new SimHash();
            sh[i].id = i;
            for (int j=0; j<hashSize; j++)
            {
               int val = dis.readInt();
               sh[i].hash[j] = val;
               //System.out.print("\t"+val);
               //if ((j+1)%8 == 0)
               //   System.out.println();
            }
            
         }
         */
         
         
         
         dis.close();
         fis.close();
      }
      catch(Exception e)
      {
         
      }
   }
   
   static void readTestHash(int numOfHash, int hashSize, SimHash[] sh, String fName, String fName2)
   {
      try
      {
         //FileInputStream fis = new FileInputStream("SimHash_"+Integer.toString(numOfHash)+".txt");
         FileInputStream fis = new FileInputStream(fName);
         DataInputStream dis = new DataInputStream(fis);
         
     
         
         for (int i=0; i<6000; i++)
         {
            //System.out.println(i);
            sh[i] = new SimHash();
            sh[i].id = i;
            for (int j=0; j<hashSize; j++)
            {
               int val = dis.readInt();
               sh[i].hash[j] = val;
               //System.out.print("\t"+val);
               //if ((j+1)%8 == 0)
               //   System.out.println();
            }
            
         }
         // fis = new FileInputStream(fName2);
         // dis = new DataInputStream(fis); 
         FileInputStream fis1 = new FileInputStream(fName2);
         DataInputStream dis1 = new DataInputStream(fis1);
         
         for (int i=6000; i<12000; i++)
         {
            //System.out.println(i);
            sh[i] = new SimHash();
            sh[i].id = i;
            for (int j=0; j<hashSize; j++)
            {
               int val = dis1.readInt();
               sh[i].hash[j] = val;
               //System.out.print("\t"+val);
               //if ((j+1)%8 == 0)
               //   System.out.println();
            }
            
         }
         
         dis.close();
         fis.close();
         dis1.close();
         fis1.close();
      }
      catch(Exception e)
      {
         
      }
   }
   
   static void analyzeHash(int numOfHash, int hashSize, SimHash[] sh) 
   {
      ArrayList<SimHash> hashList = new ArrayList<SimHash>();
      int[] hashFreq = new int[numOfHash];
      
      for (int i=0; i<numOfHash; i++)
      //for (int i=0; i<2; i++)
      {
         int pos = -1;
         //System.out.println("i="+i);
         //sh[i].print();
         for (int j=0; j<hashList.size(); j++)
         {
            //System.out.println("j="+j);
            //hashList.get(j).print();
            
            //if (hashList.contains(sh[i]))
            //if (sh[i].isEqual((SimHash)hashList.get(j)))
            if (sh[i].computeDistance(hashList.get(j)) == 0)
            {
               hashFreq[j]++;
               break;
            }
         }
         
         if (pos == -1)
         {
            hashList.add(sh[i]);
            hashFreq[hashList.size()-1] = 1;
         }
      }
      
      System.out.println("count of unique hash="+hashList.size());
   }

}